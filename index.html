<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Learn to read notes</title>
<style>
body {
  font-size: 18px;
}

.names-wrapper {
  margin-bottom: 1em;
}

.names .note {
  display: inline-block;
}

.names .name {
  height: 2.1em;
  width: 3em;
  border: 1px solid #999;
  margin: 1px 1px 1px 0;
  text-align: center;
  vertical-align: middle;
  padding-top: 0.9em;
  cursor: pointer;
}

.names .name:hover {
  background-color: #ecc;
}

.names .name.virtual {
  color: #aaa; 
}

.keybd {
}

.key {
  position: relative;
  display: inline-block;
  vertical-align: top;
  width: 20px;
  height: 150px;
  border: 1px solid black;
  margin-left: 1px;
  cursor: pointer;
  z-index: 1;
}

.key:hover {
  background-color: #ecc;
}

.key.black:hover {
  background-color: #722;
}

.key.black {
  background-color: black;
  left: 8px;
  height: 90px;
  width: 13px;
  margin-left: -15px;
  z-index: 2;
}

.key .label {
  font-size: 10px;
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
}

.key.black .label {
  color: white;
}
</style>
<script src="vexflow.js"></script>
</head>

<body>

<div class="score-wrapper" id="score-wrapper">

</div>


<div class="names-wrapper">

<div class="names" id="names">
</div>

</div>


<div class="keybd-wrapper">

<div class="keybd" id="keybd">
</div>

</div>

<script>
const noteNames = ["C","D","E","F","G","A","B"];
const noSharp = ["B","E"], noFlat = ["C","F"];
const sharp = "♯", natural = "♮", flat = "♭";

const keybdOctaves = 9, keybdStartKey = "A", keybdEndKey = "C";

var container = document.getElementById("names");

noteNames.forEach(name => {
  var wrapper = document.createElement("div");
  wrapper.className = "note";
  container.appendChild(wrapper);
  
  [sharp, null, flat].forEach(modifier => {
    var el = document.createElement("div");
    el.className = "name";
    if ((modifier == sharp && noSharp.includes(name)) || (modifier == flat && noFlat.includes(name))) {
      el.classList.add("virtual");
    }
    el.innerHTML = name + (modifier || "");
    wrapper.appendChild(el);
  });
});


var container = document.getElementById("keybd");

for (var i=0; i< keybdOctaves; i++) {
  noteNames.forEach(noteName => {
    // skip keys in first octave before keybdStartKey
    if (i==0 && noteNames.indexOf(noteName) < noteNames.indexOf(keybdStartKey)) return;
    if (i==keybdOctaves-1 && noteNames.indexOf(noteName) > noteNames.indexOf(keybdEndKey)) return;
    var lastKey = (i==keybdOctaves-1 && noteNames.indexOf(noteName) == noteNames.indexOf(keybdEndKey));
    
    function makeKey(note) {
      var key = document.createElement("div");
      key.className = "key";
      if (note.modifier) {
        key.classList.add("black");
      }
      container.appendChild(key);
    }

    makeKey({note: noteName, octave: i});
    
    if (!noSharp.includes(noteName) && !lastKey) {
      makeKey({note: noteName, modifier: sharp, octave: i});
    }
  })
}

function RndNote(options) {
  options = Object.assign({
    startOctave: 2,
    endOctave: 6,
    modifiers: true
  }, options);
  
  var candidates = [];
  
  noteNames.forEach(note => {
    if (options.modifiers && !noFlat.includes(note)) {
      candidates.push({note: note, modifier: flat});
    }
    candidates.push({note: note});
    if (options.modifiers && !noSharp.includes(note)) {
      candidates.push({note: note, modifier: sharp});
    } 
  });
    
  return function() {
    var octave = options.startOctave + Math.floor(Math.random() * (options.endOctave - options.startOctave));
    var note = candidates[Math.floor(Math.random()*candidates.length)];
    
    return {
      note: note.note,
      modifier: note.modifier,
      octave: octave,
      toString: () => this.note + (this.modifier||"") + "/" + this.octave,
      getStaveNote: function(options) {
        var sn = new VF.StaveNote(Object.assign({
          keys: [this.note + "/" + this.octave],
          duration: "w",
          clef: "treble"
        }, options));
        switch (note.modifier) {
          case flat: sn.addAccidental(0, new VF.Accidental("#")); break;
          case sharp: sn.addAccidental(0, new VF.Accidental("b")); break;
        }
        return sn;
      }
    }
  }
}

var rndNote = RndNote();

var currentNote = null;

var correct = 0, wrong = 0, time = 0;

function play() {
  currentNote = rndNote();
  drawNote(currentNote);
}

VF = Vex.Flow;

var renderer = new VF.Renderer(document.getElementById("score-wrapper"), VF.Renderer.Backends.SVG);

renderer.resize(500, 250);
var context = renderer.getContext();
context.scale(2,2);
//context.setFont("Arial", 10, "").setBackgroundFillStyle("#eed");


function drawNote(note) {

  context.clear();

  var stave = new VF.Stave(0, 0, 200);
  
  var clef = (note.octave < 4) ? "bass" : "treble";
  stave.addClef(clef);
  //stave.addKeySignature("G");

  stave.setContext(context).draw();

  var voice = new VF.Voice({num_beats: 5,  beat_value: 4});
  voice.addTickables([
    new VF.GhostNote({duration: "q" }),
    note.getStaveNote({clef: clef})
  ]);

  var formatter = new VF.Formatter().joinVoices([voice]).format([voice], 200);

  voice.draw(context, stave);
}

play();

</script>

</body>
</html>